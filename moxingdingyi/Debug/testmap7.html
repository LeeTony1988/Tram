<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
	<style type="text/css">
		body, html{width: 100%;height: 100%;margin:0;font-family:"微软雅黑";}
		#l-map{
		height:644px;
		width:1268px;
		float:left;
		}
	</style>
	<script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=of8QtCdsHA91ywzmTe3DeaWoaKbgyqzm"></script>
	<title>公交/地铁线路查询</title>
</head>
<body>
	<div id="l-map"></div>
	<div id="stationname"></div>
	<div id="message"></div>
	<div id="echarts_show"></div>
</body>

<script type="text/javascript">
	//编码协议：变量全小写，方法第一个单词首字母小写，第二个单词开始首字母大写，自编函数各个单词首字母大写
	//由C++提供城市名称以及线路名称
	var map_result = new BMap.Map("l-map");            // 创建Map实例
	//map_result.centerAndZoom("珠海", 14);
	//c++调用此函数实现地图中心点初始定位，以城市名称为传递值
	function GetCityName(cityname)
	{
		if(cityname!="")
		{
			map_result.centerAndZoom(cityname, 14);
		}
	}
	map_result.enableScrollWheelZoom();//启用滚轮放大缩小
	//map_result.setMapStyle({style:'light'});
	
	window.roadpoints_up;//存放道路所有坐标点
	window.roadpoints_down;//存放道路所有坐标点
	window.cars=new Array();
	window.carsnums=new Array();
	window.carsmarkers=new Array();
	window.busstationsarray=new Array();//存放线路站点坐标，用于判断是否到站
	window.stationsorigin=new Array();//存放从C++传来的站点名称，通过对比显示站点
      
	//为小车设置图片
	var car_icon=new BMap.Icon("./huoche.png",new BMap.Size(40,40),
	{imageOffset:new BMap.Size(5,5)});
	
	//等待地图所有模块加载完成后自动触发C++计时器
	function RunStart()
	{
		window.external.Run();
	}

	//定义小车实例,对象构造器
	function Car(carnum,cardirection,carposition,carspeed,accelerate,peopleoncar,current,voltage)
	{
		this.carnum=carnum;
		this.cardirection=cardirection;
		this.carposition=carposition;
		this.carspeed=carspeed;
		this.accelerate = accelerate;
		this.peopleoncar=peopleoncar;
		this.current = current;
		this.voltage = voltage;
	}
	
	//绘制线路函数************************//
	var busline_result=new BMap.BusLineSearch(map_result,
	{
		onGetBusListComplete:function(buslist)
		{
			busline_result.getBusLine(buslist.getBusListItem(0));
		},
		//通过回调函数获取线路坐标点数组画出线路
		onGetBusLineComplete:function(busline)
		{
			var polyline_up=new BMap.Polyline(busline.getPath(),
			{strokeColor:"#3366FF",
			 strokeWeight:'3',
			 strokeOpacity:1
			});//上行线路
			var points_origin=busline.getPath();
			var points_origin_backup=GetLineDownPoints(points_origin);
			var polyline_down=new BMap.Polyline(points_origin_backup,
			{strokeColor:"#006600",
			 strokeWeight:'3',
			 strokeOpacity:1
			});//下行线路
			//用少数点画出线路
			map_result.addOverlay(polyline_up);
			map_result.addOverlay(polyline_down);
			
			//绘制站点
			SetBusStation_Markers(busline);
			
			//增加坐标点密度
			var points_result_up=new Array();//上行线路最终浓密数组
			for(var i=0;i<points_origin.length-1;i++)
			{
				points_result_up.push.apply(points_result_up,getPoints(points_origin[i],points_origin[i+1],500));
			}
			var points_result_down=new Array();//下行线路最终浓密数组
			for(var i=0;i<points_origin_backup.length-1;i++)
			{
				points_result_down.push.apply(points_result_down,getPoints(points_origin_backup[i],points_origin_backup[i+1],500));
			}
			
			roadpoints_up=points_result_up;
			roadpoints_down=points_result_down;
			
			//InitStationMessage();
		}
	});
	
	//C++调用，初始化线路
	function InitLine(linename)
	{
		if(linename!="")
		{
			map_result.clearOverlays();
			busline_result.getBusList(linename);//显示线路及站点信息
		}
		//ShowECharts();
	}

	//初始化地图左边站点显示模块
	function InitStationMessage()
	{
		var stationmessage_result=document.getElementById("stationname");
		if(document.getElementById("ul1"))
		{
			stationmessage_result.removeChild(document.getElementById("ul1"));
			var html=new Array();
			for(var i=0;i<window.busstationsarray.length;i++)
			{
				html.push('<li><a href="javascript:void(0)" onclick="PeopleFlow(\''+window.busstationsarray[i].name+'\')">'+window.busstationsarray[i].name+'</a></li>');
			}	
			stationmessage_result.innerHTML='<ul id="ul1">'+html.join('')+'</ul>';
		}
		else
		{
			var html=new Array();
			for(var i=0;i<window.busstationsarray.length;i++)
			{
				html.push('<li><a href="javascript:void(0)" onclick="PeopleFlow(\''+window.busstationsarray[i].name+'\')">'+window.busstationsarray[i].name+'</a></li>');
			}	
			stationmessage_result.innerHTML='<ul id="ul1">'+html.join('')+'</ul>';
		}
	}
	
	//显示人流量函数
	function PeopleFlow(name)
	{
		
	}
	
	//C++调用，将不同方案的站点情况传递过来
	//清理上一线路方案中的站点信息
	function ClearStationsorigin()
	{
		window.stationsorigin=[];
	}
	//将winform传来的当前线路方案站点信息存储
	function GetStationStatus(station)
	{
		window.stationsorigin.push(station);
	}

	
	//每次传递数据后调用此函数重绘地图
	//c++调用此函数
	var flag=0;//用于表示原有数组是否包含传过来的小车信息
	function CreateCar(carnum,cardirection,carposition,showflag,carspeed,accelerate,peopleoncar,current,voltage)
	{
		if(showflag==0)//0表示绘制，1表示删除
		{
			if(window.carsnums.length==0)//第一次
			{
				window.carsnums.push(carnum);//1
				var newcar=new Car(carnum,cardirection,carposition,carspeed,accelerate,peopleoncar,current,voltage);
				window.cars.push(newcar);//2
				
				if(cardirection==0)//0上行、1下行
				{
					var car_marker=new BMap.Marker(roadpoints_up[0],{icon:car_icon});
					SetCarLabel(car_marker,carnum,carspeed,accelerate,peopleoncar,current,voltage);
					map_result.addOverlay(car_marker);
					carsmarkers.push(car_marker);//3
					
					//UpdateStationStatus(cardirection,carposition);//*****************
				}
				else if(cardirection==1)
				{
					//alert("反向坐标数组长度1："+roadpoints_down.length);
					var car_marker=new BMap.Marker(roadpoints_down[roadpoints_down.length-1],{icon:car_icon});
					SetCarLabel(car_marker,carnum,carspeed,accelerate,peopleoncar,current,voltage);
					map_result.addOverlay(car_marker);
					carsmarkers.push(car_marker);//3
				}
			}
			else            //非第一次
			{	
				for(var i=0;i<window.carsnums.length;i++)
				{
					if(window.carsnums[i]!=carnum)//不包含
					{
						flag=flag+1;
					}
					else if(window.carsnums[i]==carnum)
					{
						break;
					}
				}
				if(flag==window.carsnums.length)//不包含
				{
					window.carsnums.push(carnum);//1
					var newcar=new Car(carnum,cardirection,carposition,carspeed,accelerate,peopleoncar,current,voltage);
					window.cars.push(newcar);//2
					
					if(cardirection==0)//上行
					{
						var car_marker=new BMap.Marker(roadpoints_up[0],{icon:car_icon});
						SetCarLabel(car_marker,carnum,carspeed,accelerate,peopleoncar,current,voltage);
						map_result.addOverlay(car_marker);
						carsmarkers.push(car_marker);//3
						
						//UpdateStationStatus(cardirection,carposition);//*****************
					}
					else if(cardirection==1)//下行
					{
						var car_marker=new BMap.Marker(roadpoints_down[roadpoints_down.length-1],{icon:car_icon});
						SetCarLabel(car_marker,carnum,carspeed,accelerate,peopleoncar,current,voltage);
						map_result.addOverlay(car_marker);
						carsmarkers.push(car_marker);//3
					}
					flag=0;
				}	
				else if(flag<window.carsnums.length)//包含
				{
					var newcar=new Car(carnum,cardirection,carposition,carspeed,accelerate,peopleoncar,current,voltage);
					window.cars.splice(flag,1,newcar);
					
					if(cardirection==0)//上行
					{
						//alert("执行包含上行");
						run_up(roadpoints_up,carsmarkers[flag],carposition,cardirection);
						ResetCarLabel(carsmarkers[flag],carnum,carspeed,accelerate,peopleoncar,current,voltage);
					}
					else if(cardirection==1)//下行
					{
						//alert("执行包含下行");
						run_down(roadpoints_down,carsmarkers[flag],carposition,cardirection);
						ResetCarLabel(carsmarkers[flag],carnum,carspeed,accelerate,peopleoncar,current,voltage);
					}
					flag=0;
				}
			}
		}
		else if(showflag==1)
		{
			RemoveCar(carnum);
		}
		//InitLine();
	}
	
	//RemoveCar
	function RemoveCar(carnum)
	{
		//alert(carnum);
		//删除小车图标
		var allOverlays=map_result.getOverlays();
		//alert(allOverlays.length);
		for(var i=0;i<allOverlays.length;i++)
		{
			try
			{
				if(allOverlays[i].getLabel().content==carnum)
				{
					map_result.removeOverlay(allOverlays[i]);
				}
			}
			catch(err)
			{
			
			}
		}
		//删除各存储有关小车信息数组中该小车的数据
		for(var i=0;i<window.cars.length;i++)
		{
			try{
			if(window.cars[i].carnum==carnum)
			{
				window.cars.splice(i,1);
				window.carsmarkers.splice(i,1);
				window.carsnums.splice(i,1);
			}
			}
			catch(err){
			}
		}
	}
	
	//若C++传过来的电车编号已存在，则调用此函数移动
	function run_up(points,carmarker,carposition,cardirection)
	{
		//alert("传递值:"+carposition);
		var tmppos=parseFloat(carposition);
		
		//var new_position=Math.floor((carposition/1000000)*(points.length));
		var new_position=Math.round(tmppos*(points.length-1));
		//alert("转换值:"+new_position);
		carmarker.setPosition(points[new_position]);
		//UpdateStationStatus(cardirection,carposition);//*****************
	}
	function run_down(points,carmarker,carposition,cardirection)		
	{
		//alert("传递值:"+carposition);
		var tmppos=parseFloat(carposition);
		//var new_position=Math.floor((carposition/1000000)*(points.length));
		var new_position=Math.round(tmppos*(points.length-1));
		//alert("转换值:"+new_position);
		//alert("反向数组长度:"+points.length);
		carmarker.setPosition(points[points.length-new_position-1]);
	}
	
	
	//****************************//
		//为小车设置文字标签,显示速度加速度等
	function SetCarLabel(carmarker,carnum,carspeed,accelerate,peopleoncar,current,voltage)
	{
		var car_now_pos=carmarker.getPosition();
		var carlabel=new BMap.Label(carnum,{offset:new BMap.Size(0,-20)});
		//设置label样式
		carlabel.setStyle({
				color:"#0000FF",
				backgroundColor:"0.3",
				borderColor:"#3366CC",
				borderWidth:"2px",
				borderStyle:"dashed",
				fontSize:"12px"
			});
		carmarker.setLabel(carlabel);
		carmarker.addEventListener("mouseover",function(e){
			var templabel=carmarker.getLabel();
			templabel.setContent("电车编号:"+carnum+";<br/>"+"当前速度:"+carspeed+
			" km/h;<br/>"+"加速度:" + accelerate +"m/(s**2);<br/>"+"车内人数:"+peopleoncar+
			"人;<br/>" + "电流:" + current + "A;<br/>" +"电压:" + voltage + "V;<br/>"
			);
			templabel.setOffset(new BMap.Size(-60,-80));//-40,-60
		});
		carmarker.addEventListener("mouseout",function(e){
			var templabel=carmarker.getLabel();
			templabel.setContent(carnum);
			templabel.setOffset(new BMap.Size(0,-20));
			//templabel.setStyle({borderWidth:"0px"});
		});
	}
	function ResetCarLabel(carmarker,carnum,carspeed,accelerate,peopleoncar,current,voltage)
	{
		//var templabel=carmarker.getLabel();
		carmarker.removeEventListener("mouseover",function(e){
			var templabel=carmarker.getLabel();
			templabel.setContent("电车编号:"+carnum+";<br/>"+"当前速度:"+carspeed+
			" km/h;<br/>"+"加速度:" + accelerate +"m/(s**2);<br/>"+"车内人数:"+peopleoncar+
			"人;<br/>" + "电流:" + current + "A;<br/>" +"电压:" + voltage + "V;<br/>"
			);
			templabel.setOffset(new BMap.Size(-60,-80));//-40,-60
		});
		carmarker.removeEventListener("mouseout",function(e){
			var templabel=carmarker.getLabel();
			templabel.setContent(carnum);
			templabel.setOffset(new BMap.Size(0,-20));
			//templabel.setStyle({borderWidth:"0px"});
		});
		carmarker.addEventListener("mouseover",function(e){
			var templabel=carmarker.getLabel();
			templabel.setContent("电车编号:"+carnum+";<br/>"+"当前速度:"+carspeed+
			" km/h;<br/>"+"加速度:" + accelerate +"m/(s**2);<br/>"+"车内人数:"+peopleoncar+
			"人;<br/>" + "电流:" + current + "A;<br/>" +"电压:" + voltage + "V;<br/>"
			);
			templabel.setOffset(new BMap.Size(-60,-80));//-40,-60
		});
		carmarker.addEventListener("mouseout",function(e){
			var templabel=carmarker.getLabel();
			templabel.setContent(carnum);
			templabel.setOffset(new BMap.Size(0,-20));
			//templabel.setStyle({borderWidth:"0px"});
		});
	}
	//修改原有坐标数组，获得下行线路做标数组
	function GetLineDownPoints(points_origin)
	{
		var points_origin_backup=[];
		for(var i=0;i<points_origin.length;i++)
		{
			points_origin_backup[i]=new BMap.Point(points_origin[i].lng-0.00015,points_origin[i].lat+0.00015);
		}
		return points_origin_backup;
	}
	
	//获取地图中实际站点情况

	//用小图标标出站点位置，用文字标签显示站点名字
	function SetBusStation_Markers(busline)
	{
		window.busstationsarray=[];
		for(var i=0;i<busline.getNumBusStations();i++)
		{
			var busStation_temp=busline.getBusStation(i);
			//addCircle(i,busline,busStation_temp);
			window.busstationsarray.push(busStation_temp);
		}
		for(var j=0;j<window.busstationsarray.length;j++)
		{
			for(var k=0;k<window.stationsorigin.length;k++)
			{
				if(window.busstationsarray[j].name==window.stationsorigin[k])
				{
					addCircle(busline,window.busstationsarray[j]);
				}
			}
		}
	}
	//添加站点图标
	function addCircle(busline,busStation)
	{
		var myIcon=new BMap.Icon("./小圆点.png",new BMap.Size(13,13));
		var marker=new BMap.Marker(busStation.position,{icon:myIcon});
		map_result.addOverlay(marker);
		var myStation=new StationOverlay(busStation.position,busStation.name,"#33FFFF");
		map_result.addOverlay(myStation);
		//window.busstationmarkersarray.push(myStation);
	}
	
	//自定义站点名字标签
	//构造函数
	function StationOverlay(point,text,color)
	{
		this._point=point;
		this._text=text;
		this._color=color;
	}
	//自定义站点覆盖物继承
	StationOverlay.prototype=new BMap.Overlay();
	//初始化自定义覆盖物
	//当调用map.addOverlay方法添加自定义覆盖物时，API会调用该对象的initialize方法用来初始化覆盖物，
	//在初始化过程中需要创建覆盖物所需要的DOM元素，并添加到地图相应的容器中。
	//这里我们选择添加在容器markerPane上。
	StationOverlay.prototype.initialize=function(map)
	{
		//保存map对象实例
		this._map=map;
		//创建div元素，作为自定义覆盖物的容器
		var div=this._div=document.createElement("div");
		//z-index属性设置元素的堆叠顺序，z-index数值越大，元素就会覆盖在z-index数值小的元素上
		//z-index属性仅在节点属性为relative,absolute,fixed时生效
		div.style.position="absolute";
		div.style.zIndex=BMap.Overlay.getZIndex(this._point.lat);//设置与窗体同级，但是是数据流后方进入元素，覆盖在窗体上
		//根据参数设置元素外观
		div.style.position = "absolute";
		div.style.zIndex = BMap.Overlay.getZIndex(this._point.lat);
		div.style.backgroundColor = this._color;
		div.style.border = "1px solid #CCFF66";
		div.style.color = "black";
		div.style.height = "18px";
		div.style.padding = "2px";
		div.style.lineHeight = "18px";
		div.style.whiteSpace = "nowrap";
		div.style.MozUserSelect = "none";
		div.style.fontSize = "12px"
		var span = this._span = document.createElement("span");
		div.appendChild(span);
		span.appendChild(document.createTextNode(this._text)); 
		//var that=this;//没什么用吧？
		
		//设置自定义标注位置
		var arrow =this._arrow=document.createElement("div");
		arrow.style.position = "absolute";
		arrow.style.width = "11px";
		arrow.style.height = "10px";
		arrow.style.top = "22px";
		arrow.style.left = "10px";
		arrow.style.overflow = "hidden";
		div.appendChild(arrow);
		
		//将div添加到覆盖物容器中
		map_result.getPanes().labelPane.appendChild(div);
		//保存div实例
		//this._div=div;
		//需要将div元素作为方法的返回值，当调用覆盖物的show或者hide
		//方法的时候，以及对覆盖物移除时，也将调用div元素
		return div;
	}
	//在draw方法中设置覆盖物的位置，每当地图状态发生变化（比如：位置移动、级别变化）时，
	//API都会调用覆盖物的draw方法，用于重新计算覆盖物的位置。
	StationOverlay.prototype.draw=function()
	{
		var map = this._map;
		var pixel = map.pointToOverlayPixel(this._point);
		this._div.style.left = pixel.x - parseInt(this._arrow.style.left) +5+ "px";
		this._div.style.top  = pixel.y + 8 + "px";
	}
	
	//增加道路数据点数函数	
	function getPoints(prvePoint,newPoint,num)
	{
	var lat;
	var lng;
	var points=[];
	if(prvePoint.lng>newPoint.lng&&prvePoint.lat>newPoint.lat)
		{
		lat=Math.abs(prvePoint.lat-newPoint.lat)/num;
		lng=Math.abs(prvePoint.lng-newPoint.lng)/num;
		points[0]=prvePoint;
		for(var i=1;i<num-1;i++)
			{
			points[i]=new BMap.Point(prvePoint.lng-lng*(i+1),prvePoint.lat-lat*(i+1));
			}
		}
	if(prvePoint.lng>newPoint.lng&&prvePoint.lat<newPoint.lat)
		{                        
		lat = Math.abs(newPoint.lat-prvePoint.lat)/num;                   
		lng = Math.abs(prvePoint.lng-newPoint.lng)/num;                  
		points[0] = prvePoint;                  
		for(var i = 1;i<num-1;i++)
			{                     
			points[i] = new BMap.Point(prvePoint.lng-lng*(i+1),prvePoint.lat+lat*(i+1));                 
			}            
		}
		
	if(prvePoint.lng<newPoint.lng&&prvePoint.lat>newPoint.lat)
		{                        
		lat = Math.abs(prvePoint.lat-newPoint.lat)/num;               
		lng = Math.abs(newPoint.lng-prvePoint.lng)/num;               
		points[0] = prvePoint;                
		for(var i = 1;i<num-1;i++)
			{                    
			points[i] = new BMap.Point(prvePoint.lng+lng*(i+1),prvePoint.lat-lat*(i+1));             
			}                
		}
	if(prvePoint.lng<newPoint.lng&&prvePoint.lat<newPoint.lat)
		{                           
		lat = Math.abs(newPoint.lat-prvePoint.lat)/num;                  
		lng = Math.abs(newPoint.lng-prvePoint.lng)/num;                  
		points[0] = prvePoint;                  
		for(var i = 1;i<num-1;i++)
			{                      
			points[i] = new BMap.Point(prvePoint.lng+lng*(i+1),prvePoint.lat+lat*(i+1));                  
			}             
		}
	return points;
	}


</script>
</html>